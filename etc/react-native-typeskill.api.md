## API Report File for "react-native-typeskill"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { ComponentClass } from 'react';
import { ComponentType } from 'react';
import { ImageSourcePropType } from 'react-native';
import React from 'react';
import { StyleProp } from 'react-native';
import { TextStyle } from 'react-native';
import { ViewStyle } from 'react-native';

// @public
export namespace Attributes {
    export type GenericValue = object | TextValue | undefined;
    export type LineType = 'normal' | 'quoted';
    export interface Map {
        // (undocumented)
        readonly [k: string]: GenericValue;
    }
    export type TextValue = boolean | string | number | null;
}

// @public
export namespace Bridge {
    export type AttributesOverrideListener = (attributeName: string, attributeValue: Attributes.GenericValue) => void;
    export type ControlEvent = 'APPLY_ATTRIBUTES_TO_SELECTION' | 'APPLY_LINE_TYPE_TO_SELECTION' | 'INSERT_OR_REPLACE_AT_SELECTION';
    export interface ControlEventDomain<D extends {}> {
        applyTextTransformToSelection: (attributeName: string, attributeValue: Attributes.TextValue) => void;
        // @internal
        insertOrReplaceAtSelection: (element: Element<D>) => void;
    }
    export type Element<D extends {}> = ImageElement<D> | TextElement;
    export interface ImageElement<D extends {}> {
        // (undocumented)
        description: D;
        // (undocumented)
        type: 'image';
    }
    // @internal (undocumented)
    export type InsertOrReplaceAtSelectionListener = <D extends {}>(element: Element<D>) => void;
    export type LineTypeOverrideListener = (lineType: Attributes.LineType) => void;
    export type SelectedAttributesChangeListener = (selectedAttributes: Attributes.Map) => void;
    // @internal
    export interface SheetEventDomain {
        addApplyTextTransformToSelectionListener: (owner: object, listener: AttributesOverrideListener) => void;
        addInsertOrReplaceAtSelectionListener: (owner: object, listener: InsertOrReplaceAtSelectionListener) => void;
        release: (owner: object) => void;
    }
    // (undocumented)
    export interface TextElement {
        // (undocumented)
        content: string;
        // (undocumented)
        type: 'text';
    }
}

// @public
export class Bridge<D extends {} = {}> {
    constructor(genConfig?: Partial<Gen.Config<D>>);
    getControlEventDomain(): Bridge.ControlEventDomain<D>;
    // (undocumented)
    getGenService(): Gen.Service;
    // @internal
    getSheetEventDomain(): Bridge.SheetEventDomain;
    release(): void;
    }

// @public
export function buildInitialDocContent(): Document;

// @public
export function buildVectorIconControlSpec<T extends Toolbar.VectorIconMinimalProps>(IconComponent: ComponentType<T & Toolbar.TextControlMinimalIconProps>, actionType: ControlAction, name: string): Toolbar.ControlSpec<T>;

// @public
export function cloneDocument(content: Document): Document;

// @public
export const CONTROL_SEPARATOR: unique symbol;

// @public
export enum ControlAction {
    INSERT_IMAGE_AT_SELECTION = 4,
    SELECT_TEXT_BOLD = 0,
    SELECT_TEXT_ITALIC = 1,
    SELECT_TEXT_STRIKETHROUGH = 3,
    SELECT_TEXT_UNDERLINE = 2
}

// @public (undocumented)
export const defaultImageLocator: Images.LocationService<Images.StandardDefinition>;

// @public (undocumented)
export const defaultTextTransforms: Transforms.GenericSpec<Attributes.TextValue, 'text'>[];

// @public
export interface Document {
    readonly currentSelection: SelectionShape;
    readonly ops: GenericOp[];
    readonly selectedTextAttributes: Attributes.Map;
}

// @public
export interface DocumentRendererProps<D> {
    bridge: Bridge<D>;
    contentContainerStyle?: StyleProp<ViewStyle>;
    document: Document;
    spacing?: number;
    style?: StyleProp<ViewStyle>;
    textStyle?: StyleProp<TextStyle>;
}

// @public
export namespace Gen {
    export interface Config<D extends {}> {
        imageLocatorService: Images.LocationService<D>;
        textTransformSpecs: Transforms.GenericSpec<Attributes.TextValue, 'text'>[];
    }
    export interface Service {
        // (undocumented)
        imageLocator: Images.LocationService<any>;
        // (undocumented)
        textTransforms: Transforms;
    }
}

// @public
export interface GenericOp {
    readonly attributes?: Attributes.Map;
    // @internal
    readonly delete?: number;
    readonly insert?: string | object;
    // @internal
    readonly retain?: number;
}

// @public
export interface GenericRichContent {
    // (undocumented)
    readonly length: () => number;
    readonly ops: GenericOp[];
}

// @public
export namespace Images {
    // (undocumented)
    export interface ComponentProps<D> {
        // (undocumented)
        readonly dimensions: Dimensions;
        // (undocumented)
        readonly params: D;
    }
    // (undocumented)
    export interface Dimensions {
        // (undocumented)
        readonly height: number;
        // (undocumented)
        readonly width: number;
    }
    export interface LocationService<D> {
        readonly Component: ComponentType<ComponentProps<D>>;
        readonly computeImageDimensions: (params: D, contentWidth: number) => Dimensions;
        readonly onImageAddedEvent?: (description: D) => void;
        readonly onImageRemovedEvent?: (description: D) => void;
        readonly pickOneImage: () => Promise<D>;
    }
    // (undocumented)
    export interface StandardDefinition {
        // (undocumented)
        readonly height: number;
        // (undocumented)
        readonly source: ImageSourcePropType;
        // (undocumented)
        readonly width: number;
    }
}

// @public
export namespace Print {
    export type Props<D> = DocumentRendererProps<D>;
}

// @public
export type Print<D> = ComponentClass<Print.Props<D>>;

// @public (undocumented)
export const Print: React.ComponentClass<DocumentRendererProps<any>, any>;

// @public
export interface SelectionShape {
    readonly end: number;
    readonly start: number;
}

// @public
export interface TextOp extends GenericOp {
    readonly attributes?: Attributes.Map;
    readonly insert?: string;
}

// @public
export namespace Toolbar {
    export interface ControlSpec<T extends object = {}> {
        actionType: ControlAction;
        IconComponent: ComponentType<TextControlMinimalIconProps & T>;
        iconProps?: T extends Toolbar.VectorIconMinimalProps ? Toolbar.VectorIconMinimalProps : Partial<T>;
    }
    export type Layout = (ControlSpec<any> | typeof CONTROL_SEPARATOR)[];
    export interface Props<D> {
        activeButtonBackgroundColor?: string;
        activeButtonColor?: string;
        bridge: Bridge<D>;
        buttonSpacing?: number;
        contentContainerStyle?: StyleProp<ViewStyle>;
        iconSize?: number;
        inactiveButtonBackgroundColor?: string;
        inactiveButtonColor?: string;
        layout: Layout;
        onInsertImageError?: (e: Error) => void;
        selectedTextAttributes: Attributes.Map;
        separatorColor?: string;
        style?: StyleProp<ViewStyle>;
    }
    export interface TextControlMinimalIconProps {
        color?: string;
        size?: number;
    }
    export interface VectorIconMinimalProps {
        name: string;
    }
}

// @public
export type Toolbar<D> = ComponentClass<Toolbar.Props<D>>;

// @public (undocumented)
export const Toolbar: React.ComponentClass<Toolbar.Props<any>, any>;

// @public
export namespace Transforms {
    export type BoolSpec<T extends TargetType = 'block'> = GenericSpec<true, T>;
    // @internal
    export interface Dict<A extends Attributes.GenericValue, T extends TargetType> {
        // (undocumented)
        [attributeName: string]: GenericSpec<A, T>[];
    }
    export interface GenericSpec<A extends Attributes.GenericValue, T extends TargetType> {
        activeAttributeValue: A;
        activeStyle: T extends 'block' ? ViewStyle : TextStyle;
        attributeName: string;
    }
    export type TargetType = 'block' | 'text';
    export type TextAttributeName = 'bold' | 'italic' | 'textDecoration';
}

// @public
export class Transforms {
    constructor(textTransformSpecs: Transforms.GenericSpec<Attributes.TextValue, 'text'>[]);
    // @internal
    getStylesFromOp(op: TextOp): StyleProp<TextStyle>;
    }

// @public
export namespace Typer {
    export interface Props<D> extends DocumentRendererProps<D> {
        debug?: boolean;
        onDocumentUpdate?: (nextDocumentContent: Document) => Promise<void>;
        underlayColor?: string;
    }
}

// @public
export type Typer<D> = ComponentClass<Typer.Props<D>>;

// @public (undocumented)
export const Typer: React.ComponentClass<Typer.Props<any>, any>;


```
