## API Report File for "react-native-typeskill"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { ComponentClass } from 'react';
import { ComponentType } from 'react';
import React from 'react';
import { StyleProp } from 'react-native';
import { TextStyle } from 'react-native';
import { ViewStyle } from 'react-native';

// @public
export namespace Attributes {
    export type GenericValue = object | TextValue | undefined;
    export type LineType = 'normal' | 'quoted';
    export interface Map {
        // (undocumented)
        readonly [k: string]: GenericValue;
    }
    export type TextValue = boolean | string | number | null;
}

// @public
export namespace Bridge {
    export type AttributesOverrideListener = (attributeName: string, attributeValue: Attributes.GenericValue) => void;
    export type ControlEvent = 'APPLY_ATTRIBUTES_TO_SELECTION' | 'INSERT_OR_REPLACE_AT_SELECTION';
    export interface ControlEventDomain<ImageSource> {
        applyTextTransformToSelection: (attributeName: string, attributeValue: Attributes.TextValue) => void;
        // @internal
        insertOrReplaceAtSelection: (element: Element<ImageSource>) => void;
    }
    export type Element<ImageSource> = ImageElement<ImageSource> | TextElement;
    export interface ImageElement<Source> {
        // (undocumented)
        description: Images.Description<Source>;
        // (undocumented)
        type: 'image';
    }
    // @internal (undocumented)
    export type InsertOrReplaceAtSelectionListener<ImageSource> = <D extends {}>(element: Element<ImageSource>) => void;
    export type LineTypeOverrideListener = (lineType: Attributes.LineType) => void;
    export type SelectedAttributesChangeListener = (selectedAttributes: Attributes.Map) => void;
    // @internal
    export interface SheetEventDomain<ImageSource> {
        addApplyTextTransformToSelectionListener: (owner: object, listener: AttributesOverrideListener) => void;
        addInsertOrReplaceAtSelectionListener: (owner: object, listener: InsertOrReplaceAtSelectionListener<ImageSource>) => void;
        release: (owner: object) => void;
    }
    // (undocumented)
    export interface TextElement {
        // (undocumented)
        content: string;
        // (undocumented)
        type: 'text';
    }
}

// @public
export interface Bridge<ImageSource> {
    getControlEventDomain: () => Bridge.ControlEventDomain<ImageSource>;
    // @internal
    getSheetEventDomain: () => Bridge.SheetEventDomain<ImageSource>;
    release: () => void;
}

// @public (undocumented)
export const Bridge: {};

// @public
export function buildBridge<ImageSource>(): Bridge<ImageSource>;

// @public
export function buildEmptyDocument(): Document;

// @public
export function buildVectorIconControlSpec<T extends Toolbar.VectorIconMinimalProps>(IconComponent: ComponentType<T & Toolbar.TextControlMinimalIconProps>, actionType: ControlAction, name: string): Toolbar.ControlSpec<T>;

// @public
export function cloneDocument(content: Document): Document;

// @public
export const CONTROL_SEPARATOR: unique symbol;

// @public
export enum ControlAction {
    INSERT_IMAGE_AT_SELECTION = 4,
    SELECT_TEXT_BOLD = 0,
    SELECT_TEXT_ITALIC = 1,
    SELECT_TEXT_STRIKETHROUGH = 3,
    SELECT_TEXT_UNDERLINE = 2
}

// @public (undocumented)
export const defaultTextTransforms: Transforms.GenericSpec<Attributes.TextValue, 'text'>[];

// @public
export interface Document {
    readonly currentSelection: SelectionShape;
    readonly ops: GenericOp[];
    readonly selectedTextAttributes: Attributes.Map;
}

// @public
export interface DocumentRendererProps<ImageSource> {
    contentContainerStyle?: StyleProp<ViewStyle>;
    document: Document;
    ImageComponent?: Images.Component<ImageSource>;
    maxMediaBlockHeight?: number;
    maxMediaBlockWidth?: number;
    spacing?: number;
    style?: StyleProp<ViewStyle>;
    textStyle?: StyleProp<TextStyle>;
    textTransformSpecs?: Transforms.Specs<'text'>;
}

// @public
export interface GenericOp {
    readonly attributes?: Attributes.Map;
    // @internal
    readonly delete?: number;
    readonly insert?: string | object;
    // @internal
    readonly retain?: number;
}

// @public
export interface GenericRichContent {
    // (undocumented)
    readonly length: () => number;
    readonly ops: GenericOp[];
}

// @public
export namespace Images {
    // (undocumented)
    export type Component<Source> = ComponentType<ComponentProps<Source>>;
    // (undocumented)
    export interface ComponentProps<Source> {
        readonly description: Description<Source>;
        readonly printDimensions: Dimensions;
    }
    // (undocumented)
    export interface Description<Source> {
        // (undocumented)
        readonly height: number;
        // (undocumented)
        readonly source: Source;
        // (undocumented)
        readonly width: number;
    }
    // (undocumented)
    export interface Dimensions {
        // (undocumented)
        readonly height: number;
        // (undocumented)
        readonly width: number;
    }
    export interface Hooks<Source> {
        readonly onImageAddedEvent?: (description: Description<Source>) => void;
        readonly onImageRemovedEvent?: (description: Description<Source>) => void;
    }
    // (undocumented)
    export interface StandardSource {
        // (undocumented)
        uri: string;
    }
}

// @public
export namespace Print {
    export type Props = DocumentRendererProps<any>;
}

// @public
export type Print = ComponentClass<Print.Props>;

// @public (undocumented)
export const Print: React.ComponentClass<DocumentRendererProps<any>, any>;

// @public
export interface SelectionShape {
    readonly end: number;
    readonly start: number;
}

// @public
export interface TextOp extends GenericOp {
    readonly attributes?: Attributes.Map;
    readonly insert?: string;
}

// @public
export namespace Toolbar {
    export interface ControlSpec<T extends object = {}> {
        actionType: ControlAction;
        IconComponent: ComponentType<TextControlMinimalIconProps & T>;
        iconProps?: T extends Toolbar.VectorIconMinimalProps ? Toolbar.VectorIconMinimalProps : Partial<T>;
    }
    export type Layout = (ControlSpec<any> | typeof CONTROL_SEPARATOR)[];
    export interface Props<ImageSource> {
        activeButtonBackgroundColor?: string;
        activeButtonColor?: string;
        bridge: Bridge<ImageSource>;
        buttonSpacing?: number;
        contentContainerStyle?: StyleProp<ViewStyle>;
        iconSize?: number;
        inactiveButtonBackgroundColor?: string;
        inactiveButtonColor?: string;
        layout: Layout;
        onInsertImageError?: (e: Error) => void;
        pickOneImage?: () => Promise<Images.Description<ImageSource>>;
        selectedTextAttributes: Attributes.Map;
        separatorColor?: string;
        style?: StyleProp<ViewStyle>;
    }
    export interface TextControlMinimalIconProps {
        color?: string;
        size?: number;
    }
    export interface VectorIconMinimalProps {
        name: string;
    }
}

// @public
export type Toolbar = ComponentClass<Toolbar.Props<any>>;

// @public (undocumented)
export const Toolbar: React.ComponentClass<Toolbar.Props<any>, any>;

// @public
export namespace Transforms {
    export type BoolSpec<T extends TargetType = 'block'> = GenericSpec<true, T>;
    // @internal
    export interface Dict<A extends Attributes.GenericValue, T extends TargetType> {
        // (undocumented)
        [attributeName: string]: GenericSpec<A, T>[];
    }
    export interface GenericSpec<A extends Attributes.GenericValue, T extends TargetType> {
        activeAttributeValue: A;
        activeStyle: T extends 'block' ? ViewStyle : TextStyle;
        attributeName: string;
    }
    // (undocumented)
    export type Specs<T extends 'text' | 'block' = 'text'> = GenericSpec<Attributes.TextValue, T>[];
    export type TargetType = 'block' | 'text';
    export type TextAttributeName = 'bold' | 'italic' | 'textDecoration';
}

// @public
export class Transforms {
    constructor(textTransformSpecs: Transforms.GenericSpec<Attributes.TextValue, 'text'>[]);
    // @internal
    getStylesFromOp(op: TextOp): StyleProp<TextStyle>;
    }

// @public
export namespace Typer {
    export interface Props<ImageSource> extends DocumentRendererProps<ImageSource> {
        bridge: Bridge<ImageSource>;
        debug?: boolean;
        imageHooks?: Images.Hooks<ImageSource>;
        onDocumentUpdate?: (nextDocumentContent: Document) => Promise<void>;
        readonly?: boolean;
        underlayColor?: string;
    }
}

// @public
export type Typer = ComponentClass<Typer.Props<any>>;

// @public (undocumented)
export const Typer: React.ComponentClass<Typer.Props<any>, any>;


```
