## API Report File for "react-native-typeskill"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { ComponentClass } from 'react';
import { ComponentType } from 'react';
import React from 'react';
import { StyleProp } from 'react-native';
import { TextStyle } from 'react-native';
import { ViewStyle } from 'react-native';

// @public
export namespace Attributes {
    export type GenericValue = object | TextValue | undefined;
    export type LineType = 'normal' | 'quoted';
    export interface Map {
        // (undocumented)
        readonly [k: string]: GenericValue;
    }
    export type TextValue = boolean | string | number | null;
}

// @public
export namespace Bridge {
    export type AttributesOverrideListener = (attributeName: string, attributeValue: Attributes.GenericValue) => void;
    // (undocumented)
    export interface Config<D extends {}> {
        imageLocatorService: ImageLocationService<D>;
        textTransformSpecs: Transforms.GenericSpec<Attributes.TextValue, 'text'>[];
    }
    export type ControlEvent = 'APPLY_ATTRIBUTES_TO_SELECTION' | 'APPLY_LINE_TYPE_TO_SELECTION' | 'INSERT_OR_REPLACE_AT_SELECTION';
    export interface ControlEventDomain<D extends {}> {
        addSelectedAttributesChangeListener: (owner: object, listener: SelectedAttributesChangeListener) => void;
        applyTextTransformToSelection: (attributeName: string, attributeValue: Attributes.TextValue) => void;
        // @internal
        insertOrReplaceAtSelection: (element: Element<D>) => void;
        release: (owner: object) => void;
    }
    export type Element<D extends {}> = ImageElement<D> | TextElement;
    export interface ImageElement<D extends {}> {
        // (undocumented)
        description: D;
        // (undocumented)
        type: 'image';
    }
    export interface ImageLocationService<D extends {}> {
        Component: ComponentType<D>;
        onImageAddedEvent?: (description: D) => void;
        onImageRemovedEvent?: (description: D) => void;
        pickOneImage: () => Promise<D>;
    }
    // @internal (undocumented)
    export type InsertOrReplaceAtSelectionListener = <D extends {}>(element: Element<D>) => void;
    export type LineTypeOverrideListener = (lineType: Attributes.LineType) => void;
    export type SelectedAttributesChangeListener = (selectedAttributes: Attributes.Map) => void;
    export type SheetEvent = 'SELECTED_ATTRIBUTES_CHANGE' | 'SELECTED_LINE_TYPE_CHANGE';
    // @internal
    export interface SheetEventDomain {
        addApplyTextTransformToSelectionListener: (owner: object, listener: AttributesOverrideListener) => void;
        addInsertOrReplaceAtSelectionListener: (owner: object, listener: InsertOrReplaceAtSelectionListener) => void;
        // (undocumented)
        getTransforms(): Transforms;
        notifySelectedLineTypeChange: (selectionLineType: Attributes.LineType) => void;
        notifySelectedTextAttributesChange: (attributesMap: Attributes.Map) => void;
        release: (owner: object) => void;
    }
    // (undocumented)
    export interface TextElement {
        // (undocumented)
        content: string;
        // (undocumented)
        type: 'text';
    }
}

// @public
export class Bridge<D extends {} = {}> {
    constructor(config?: Partial<Bridge.Config<any>>);
    getControlEventDomain(): Bridge.ControlEventDomain<D>;
    getImageLocator(): Bridge.ImageLocationService<any>;
    // @internal
    getSheetEventDomain(): Bridge.SheetEventDomain;
    getTransforms(): Transforms;
    release(): void;
    }

// @public
export function buildVectorIconControlSpec<T extends Toolbar.VectorIconMinimalProps>(IconComponent: ComponentType<T & Toolbar.TextControlMinimalIconProps>, actionType: ControlAction, name: string): Toolbar.ControlSpec<T>;

// @public
export const CONTROL_SEPARATOR: unique symbol;

// @public
export enum ControlAction {
    INSERT_IMAGE_AT_SELECTION = 4,
    SELECT_TEXT_BOLD = 0,
    SELECT_TEXT_ITALIC = 1,
    SELECT_TEXT_STRIKETHROUGH = 3,
    SELECT_TEXT_UNDERLINE = 2
}

// @public
export interface GenericOp {
    readonly attributes?: Attributes.Map;
    // @internal
    readonly delete?: number;
    readonly insert?: string | object;
    // @internal
    readonly retain?: number;
}

// @public
export interface GenericRichContent {
    // (undocumented)
    readonly length: () => number;
    readonly ops: GenericOp[];
}

// @public
export class RichContent implements GenericRichContent {
    static fromJSON(serializedContent: string): RichContent;
    static fromOps(ops?: GenericOp[]): RichContent;
    // (undocumented)
    length(): number;
    readonly ops: GenericOp[];
    toJSON(): string;
    toText(): string;
}

// @public
export namespace RichText {
    export interface Props {
        richContent: GenericRichContent;
        textStyle?: StyleProp<TextStyle>;
        transforms: Transforms;
    }
}

// @public
export type RichText = ComponentClass<RichText.Props>;

// @public (undocumented)
export const RichText: React.ComponentClass<RichText.Props, any>;

// @public
export namespace Sheet {
    export interface Props {
        bridge: Bridge;
        contentContainerStyle?: StyleProp<ViewStyle>;
        initialRichContent?: RichContent;
        onRichContentUpdate?: (richText: RichContent) => void;
        textStyle?: StyleProp<TextStyle>;
    }
}

// @public
export type Sheet = ComponentClass<Sheet.Props>;

// @public (undocumented)
export const Sheet: React.ComponentClass<Sheet.Props, any>;

// @public
export interface TextOp extends GenericOp {
    readonly attributes?: Attributes.Map;
    readonly insert?: string;
}

// @public
export namespace Toolbar {
    export interface ControlSpec<T extends object = {}> {
        actionType: ControlAction;
        IconComponent: ComponentType<TextControlMinimalIconProps & T>;
        iconProps?: T extends Toolbar.VectorIconMinimalProps ? Toolbar.VectorIconMinimalProps : Partial<T>;
    }
    export type Layout = (ControlSpec<any> | typeof CONTROL_SEPARATOR)[];
    export interface Props<D extends {}> {
        activeButtonBackgroundColor?: string;
        activeButtonColor?: string;
        bridge: Bridge<D>;
        buttonSpacing?: number;
        contentContainerStyle?: StyleProp<ViewStyle>;
        iconSize?: number;
        inactiveButtonBackgroundColor?: string;
        inactiveButtonColor?: string;
        layout: Layout;
        onInsertImageError?: (e: Error) => void;
        separatorColor?: string;
        style?: StyleProp<ViewStyle>;
    }
    export interface TextControlMinimalIconProps {
        color?: string;
        size?: number;
    }
    export interface VectorIconMinimalProps {
        name: string;
    }
}

// @public
export type Toolbar<D extends {}> = ComponentClass<Toolbar.Props<D>>;

// @public (undocumented)
export const Toolbar: React.ComponentClass<Toolbar.Props<any>, any>;

// @public
export namespace Transforms {
    export type BoolSpec<T extends TargetType = 'block'> = GenericSpec<true, T>;
    // @internal
    export interface Dict<A extends Attributes.GenericValue, T extends TargetType> {
        // (undocumented)
        [attributeName: string]: GenericSpec<A, T>[];
    }
    export interface GenericSpec<A extends Attributes.GenericValue, T extends TargetType> {
        activeAttributeValue: A;
        activeStyle: T extends 'block' ? ViewStyle : TextStyle;
        attributeName: string;
    }
    export type TargetType = 'block' | 'text';
    export type TextAttributeName = 'bold' | 'italic' | 'textDecoration';
}

// @public
export class Transforms {
    constructor(textTransformSpecs: Transforms.GenericSpec<Attributes.TextValue, 'text'>[]);
    // @internal
    getStylesFromOp(op: TextOp): StyleProp<TextStyle>;
    }


```
